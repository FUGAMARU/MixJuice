## templatesディレクトリーに入れるコンポーネントの基準

とある明確な1つの機能や用途を持っていたり、主に親コンポーネントのソースの見通しを良くするために機能や用途単位でコンポーネントとして切り出した、いわゆる「再利用性の低い」コンポーネントを`templates`ディレクトリーに入れる。  
`templates`に入るようなコンポーネントは、どのページでのみ使うかが決まっている事がほとんどなので、`templates`ディレクトリー内でさらにページ毎にディレクトリー分けしている。  
`templates`ディレクトリーに入るコンポーネントの実装が、`parts`ディレクトリーに入っているコンポーネントのみで構成されているとは限らない。

## エラーハンドリング方針

- 例外を投げるのはAPIにリクエストを送るローレベルな箇所のみ。
- `try / catch`はユーザー操作由来のイベントハンドラーなど、1番上のハイレベルな層にのみ置く。つまり、処理の中間に位置するカスタムフック内の関数などは`try / catch`でラップしない。ただし、Spotifyのアクセストークンの更新などを担う`useSpotifyToken`では、例外的に関数を`try / catch`でラップして、直接エラーモーダルを表示している。

## usePlayerで扱っているステートを全てグローバルステート化してpropsによるバケツリレーをやめることができない理由

メインページ以外でusePlayerを利用する際、イベントリスナーが重複することによる二重処理などが行われないようにするため、引数には`{initialize: false}`を渡すことになるが、`initialize`が`false`の場合、usePlayer配下のフック(例: useSpotifyPlayer)の引数も`{initialize: false}`になるので、usePlayer配下のフックのuseEffectも作動しなくなり、再生位置の更新などがされなくなる。

## ユーザーデーターが未取得かどうか判定するためにいちいちuseRecoilStateを使ってユーザーデーターを引っ張ってきている理由

useStorage内に

```TSX
const userData = useRecoilValue(userDataAtom)
const isLoadingUserData = useMemo(() => !isDefined(userData),[userData])
return { isLoadingUserData } as const
```

のような変数を設けてそれを使って判定するようにすればコードの見通しも良くなるのだろうが、`useSetSpotifySettingState`にて、何故か`isLoadingUserData`が`false`なのにも関わらず`userData`が`undefined`のままという事象が発生したので、ユーザーデーターが未取得か判定したい場合は都度useRecoilStateを利用してユーザーデーターを引っ張ってきている。
